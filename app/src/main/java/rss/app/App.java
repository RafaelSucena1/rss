/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rss.app;


import de.unipassau.wolfgangpopp.xmlrss.wpprovider.*;
import de.unipassau.wolfgangpopp.xmlrss.wpprovider.grss.GLRSSSignatureOutput;
import rss.app.utils.pdf.FileByBlocks;
import rss.app.utils.rss.GLExportSignature;
import rss.app.utils.rss.GLImportSignature;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.util.*;

public class App {
    RedactableSignature rss1;
    RedactableSignature rss2;
    private PublicKey publicKey;
    private KeyPair   glRssKeyPair;

    private PublicKey importedPublicKey;
    private PublicKey generatedPublicKey;

    public static void main(String[] args) throws Exception {
        System.out.println("Working Directory = " + System.getProperty("user.dir"));

        java.security.Security.addProvider(new WPProvider());
        App app = new App();
        app.exportSignature();
        SignatureOutput signatureOutput = app.importSignature("name.pdf", "app/testdata/signature.sig");
        RedactableSignature rss = RedactableSignature.getInstance("GLRSSwithRSAandBPA");
        rss.initVerify(app.importedPublicKey);
        boolean goodSign = rss.verify((GLRSSSignatureOutput) signatureOutput);
        if(goodSign) {
            System.out.println("the imported key is ok");
        } else {
            System.out.println("the imported key is  NOT NOT NOT  ok");
        }
    }


    public byte[][] getBytes(String fileName) {
        FileByBlocks blocks = new FileByBlocks("app/testdata/" + fileName);
        String[] linesArray = blocks.getFullText().split(System.lineSeparator());
        byte[][] finalVariable = new byte[linesArray.length][];
        int i = 0;
        for (String line : linesArray) {
            finalVariable[i] = line.getBytes(StandardCharsets.UTF_8);
            i++;
        }
        return finalVariable;
    }
    private SignatureOutput importSignature(String doc, String signFile) throws Exception {
        GLImportSignature glImportSignature = new GLImportSignature(new File(signFile));
        this.importedPublicKey = glImportSignature.getPublicKey();
        return glImportSignature.getSignatureOutput(getBytes(doc));
    }

    private void exportSignature() throws Exception {
        System.out.println("reached exportSignature");

        SignatureOutput signatureOutput = this.testSign("name.pdf");
        GLExportSignature glExportSignature = new GLExportSignature((GLRSSSignatureOutput) signatureOutput, glRssKeyPair.getPublic());

        byte[] export = glExportSignature.getEncoded();
        File newFile = new File("app/testdata/signature.sig");
        newFile.delete();

        FileOutputStream fileOutputStream = new FileOutputStream(newFile);

        fileOutputStream.write(export);
        fileOutputStream.close();
    }

    public void initKeys() throws NoSuchAlgorithmException {
        KeyPairGenerator glRssGenerator = KeyPairGenerator.getInstance("GLRSSwithRSAandBPA");

        KeyPair glRssKeyPair = glRssGenerator.generateKeyPair();
        this.glRssKeyPair = glRssKeyPair;
        publicKey = glRssKeyPair.getPublic();

    }

    public App() throws RedactableSignatureException, IOException, NoSuchAlgorithmException, InvalidKeyException {
    }

    public SignatureOutput redact2(String fileName) throws NoSuchAlgorithmException, InvalidKeyException, RedactableSignatureException, IOException {
        System.out.println("reached redact2");
        FileByBlocks blocks = new FileByBlocks("app/testdata/" + fileName);

        KeyPairGenerator glRssGenerator = KeyPairGenerator.getInstance("GLRSSwithRSAandBPA");

        KeyPair glRssKeyPair = glRssGenerator.generateKeyPair();
        Base64.Encoder encoder = Base64.getEncoder();
        System.out.println("public key: "+encoder.encodeToString(glRssKeyPair.getPublic().getEncoded()));
        this.glRssKeyPair = glRssKeyPair;
        System.out.println("finished generating keypair");
        publicKey = glRssKeyPair.getPublic();

        String[] linesArray = blocks.getFullText().split(System.lineSeparator());
        byte[] bArray;
        int max = linesArray.length - 1;
        byte[][] linesAsBytes = new byte[max][];

        List<Identifier> rssIdentifiers = new ArrayList<Identifier>();
        RedactableSignature rss = initializeRss();
        byte[] chunk;
        for (String line : linesArray) {
            chunk = line.getBytes(StandardCharsets.UTF_8);
            rssIdentifiers.add(rss.addPart(chunk, true));
        }

        rss.initSign(glRssKeyPair);
        SignatureOutput signatureOutput = rss.sign();
        return signatureOutput;
        /*for (Identifier identifier : rssIdentifiers){

            rss.addIdentifier(identifier);
        }*/
/*        rss.initRedact(publicKey);
        SignatureOutput newSign = rss.redact(signatureOutput);*/
    }

    public SignatureOutput testSign(String fileName) throws NoSuchAlgorithmException, InvalidKeyException, RedactableSignatureException, IOException {
        System.out.println("reached testSign");
        FileByBlocks blocks = new FileByBlocks("app/testdata/" + fileName);
        String[] linesArray = blocks.getFullText().split(System.lineSeparator());

        this.initKeys();


        byte[] bArray;
        int max = linesArray.length - 1;
        byte[][] linesAsBytes = new byte[max][];

        List<Identifier> rssIdentifiers = new ArrayList<Identifier>();
        RedactableSignature rss = initializeRss();
        byte[] chunk;
        rss.initSign(glRssKeyPair);

        for (String line : linesArray) {
            System.out.println(line);
            chunk = line.getBytes(StandardCharsets.UTF_8);
            rssIdentifiers.add(rss.addPart(chunk));
        }

        SignatureOutput signatureOutput = rss.sign();
        rss.initVerify(publicKey);
        System.out.println(rss.verify(signatureOutput) ? "signature TRUE" : "Signature FALSE");
        return signatureOutput;

    }

        public void redact() throws NoSuchAlgorithmException, InvalidKeyException, IOException, RedactableSignatureException {
        java.security.Security.addProvider(new WPProvider());
        KeyPairGenerator glRssGenerator = KeyPairGenerator.getInstance("GLRSSwithRSAandBPA");


        KeyPair glRssKeyPair = glRssGenerator.generateKeyPair();
        this.glRssKeyPair = glRssKeyPair;
        System.out.println("finished generating keypair");
        publicKey = glRssKeyPair.getPublic();

        RedactableSignature rss1 = initializeRss();
        //RedactableSignature rss2 = initializeRss();
        SignatureOutput signFull = signDocByLine("test1.xml",  rss1);

        GLExportSignature glExportSignature = new GLExportSignature((GLRSSSignatureOutput) signFull, publicKey);
        byte[] export  = glExportSignature.getEncoded();


/*        SignatureOutput signRss  = signDocByLine("test1.xsd", rss2);
        rss1.initVerify(publicKey);
        if (rss1.verify(signFull)) {
            System.out.println("old signature still valid");
        } else {
            System.out.println("old signature not valid");
        }*/
    }

    public RedactableSignature initializeRss() throws NoSuchAlgorithmException, InvalidKeyException {
        RedactableSignature rss = RedactableSignature.getInstance("GLRSSwithRSAandBPA");
        rss.initSign(glRssKeyPair);
        return rss;
    }

    public SignatureOutput signDocByLine(String file, RedactableSignature rss) throws IOException, RedactableSignatureException, InvalidKeyException, NoSuchAlgorithmException {
        List<String> linesList = Files.readAllLines(Paths.get("app/testdata/" + file));
        String[] linesArray = linesList.toArray(new String[0]);
        byte[] bArray;
        int max = linesArray.length - 1;
        byte[][] linesAsBytes = new byte[max][];

        List<Identifier> rssIdentifiers = new ArrayList<Identifier>();
        List<Identifier> notRssIdentifiers = new ArrayList<Identifier>();

        byte[] chunk;
        for (String line : linesArray) {
            chunk = line.getBytes(StandardCharsets.UTF_8);
            if(line.startsWith("  ~")){
                rssIdentifiers.add(rss.addPart(chunk));
            } else {
                notRssIdentifiers.add(rss.addPart(chunk, false));
            }
        }

        SignatureOutput signatureOutput = rss.sign();

        /*for (Identifier identifier : rssIdentifiers){

            rss.addIdentifier(identifier);
        }*/
        rss.initRedact(publicKey);
        SignatureOutput newSign = rss.redact(signatureOutput);
        //rss.initVerify(publicKey);

        return signatureOutput;
    }
}